<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced brms custom families: occupancy models and the `flocker_data` format • flocker</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Advanced brms custom families: occupancy models and the `flocker_data` format">
<meta property="og:description" content="flocker">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flocker</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.2-0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/augmented_models.html">Data-augmented models in flocker</a>
    </li>
    <li>
      <a href="../articles/flocker_format.html">Advanced brms custom families: occupancy models and the `flocker_data` format</a>
    </li>
    <li>
      <a href="../articles/flocker_tutorial.html">Fitting occupancy models with flocker</a>
    </li>
    <li>
      <a href="../articles/multiseason_models.html">Multiseason models in flocker</a>
    </li>
    <li>
      <a href="../articles/nonlinear_models.html">Nonlinear models in flocker</a>
    </li>
    <li>
      <a href="../articles/sbc.html">SBC for flocker models</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/jsocolar/flocker/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Advanced brms custom families: occupancy models
and the <code>flocker_data</code> format</h1>
                        <h4 data-toc-skip class="author">Jacob
Socolar</h4>
            
            <h4 data-toc-skip class="date">2023-11-03</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jsocolar/flocker/blob/HEAD/vignettes/flocker_format.Rmd" class="external-link"><code>vignettes/flocker_format.Rmd</code></a></small>
      <div class="hidden name"><code>flocker_format.Rmd</code></div>

    </div>

    
    
<p><img align="right" src="../reference/figures/flocker_sticker.png" width="30%"></p>
<p><code>brms</code> offers the option to specify models that
incorporate <code>Stan</code> code for custom likelihood functions.
<code>brms</code> can then fit models using these likelihoods where the
distributional parameters of the custom likelihood are given linear
predictors in the usual way. Relatively straightforward examples are
given in the <a href="https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html" class="external-link">brms
custom families vignette</a>, but <code>brms</code> provides surprising
flexibility to do fancy things with custom families. In this vignette, I
show how we use this flexibility to harness <code>brms</code> to
occupancy modeling likelihoods. I assume that the reader knows a little
bit about <a href="https://jsocolar.github.io/closureOccupancy/" class="external-link">occupancy models</a>
and <code>brms</code>, but not much else.</p>
<div class="section level2">
<h2 id="the-problem">The problem<a class="anchor" aria-label="anchor" href="#the-problem"></a>
</h2>
<p>The challenge in shoehorning an occupancy model into a
<code>brms</code> custom family is that each multiplicative term in the
occupancy-model likelihood represents a <a href="https://jsocolar.github.io/flocker/articles/flocker_tutorial.html#terms-and-definitions" class="external-link">closure-unit</a>
that might contain multiple repeat visits <em>with different detection
covariates</em>. The likelihood does not factorize at the visit level
and therefore must be computed unit-wise, but the linear predictor for
detection needs to be computed visit-wise. How can we tell
<code>brms</code> to compute a visit-wise detection predictor without
telling it to try to compute a visit-wise log-likelihood?</p>
</div>
<div class="section level2">
<h2 id="two-key-tricks-unlooped-families-and-vint-terms">Two key tricks: unlooped families and <code>vint</code> terms<a class="anchor" aria-label="anchor" href="#two-key-tricks-unlooped-families-and-vint-terms"></a>
</h2>
<p>The first trick involves the unassuming <code>loop</code> argument to
<code><a href="https://paul-buerkner.github.io/brms/reference/custom_family.html" class="external-link">brms::custom_family()</a></code>. Defaulting to <code>TRUE</code>,
<code>loop</code> controls whether or not the custom likelihood will be
evaluated row-wise. The <code><a href="https://paul-buerkner.github.io/brms/reference/custom_family.html" class="external-link">brms::custom_family</a></code> documentation
points out that setting <code>loop = FALSE</code> can enable efficient
vectorized computation of the likelihood. We are going to co-opt this
argument for a different purpose. We are going to perform a custom
likelihood computation that has access to all rows of the data
simultaneously not to enable vectorization, but to ensure that the
likelihood can “see” all of the relevant visits simultaneously as it
computes the unit-wise likelihood.</p>
<p>Let’s think this through: our likelihood function is going to ingest
a one-dimensional array <code>y</code> of visit-wise integer response
data, and then vectors of pre-computed linear predictors for two
distributional parameters: <code>occ</code> for occupancy and
<code>det</code> for detection. If we have <span class="math inline">\(M\)</span> total visits to each site, then <span class="math inline">\(\frac{M-1}{M}\)</span> of the elements of
<code>occ</code> will be redundant (since the occupancy predictor cannot
change across visits), but there will be no redundancy in <code>y</code>
nor <code>det</code>.</p>
<p>What we need now is a likelihood function that can associate each row
with the correct closure-unit. Here’s where the second trick comes in.
Some likelihoods require “extra” response data that inform the
likelihood without being involved in the computation of the linear
predictors. The canonical example is the number of trials in a binomial
response. To supply such data in custom likelihoods, <code>brms</code>
provides the functions <code>vint()</code> and <code>vreal()</code> (for
integer and real data respectively). We are going to use repeated calls
to <code>vint()</code> to inject all of the necessary indexing
information into the likelihood.</p>
</div>
<div class="section level2">
<h2 id="the-flocker_data-format-for-a-single-season-model">The <code>flocker_data</code> format for a single-season model<a class="anchor" aria-label="anchor" href="#the-flocker_data-format-for-a-single-season-model"></a>
</h2>
<p>Suppose the model has <span class="math inline">\(N\)</span> unique
closure-units, and the maximum number of visits to any closure-unit is
<span class="math inline">\(M\)</span>. We will ensure that the data are
formatted such that the first <span class="math inline">\(N\)</span>
rows correspond to the first visits to each closure-unit. Then we will
pass <span class="math inline">\(M\)</span> <code>vint</code> terms
whose first <span class="math inline">\(N\)</span> elements each give
the row indices <span class="math inline">\(i\)</span> corresponding to
the <span class="math inline">\(m\)</span>th visit to that closure-unit,
for <span class="math inline">\(m\)</span> in <span class="math inline">\(1\)</span> to <span class="math inline">\(M\)</span>. All subsequent elements with indices
<span class="math inline">\(i &gt; N\)</span> are irrelevant. Note that
the first of these <code>vint</code> arrays is redundant and contains as
its first <span class="math inline">\(N\)</span> elements simply the
integers from 1 to <span class="math inline">\(N\)</span>. We include it
anyway to keep the code logic transparent and avoid bugs. Moreover, it
will become relevant in more advanced multi-season models where it is
possible to have closure-units that receive zero visits but still are
relevant to the likelihood (see <a href="#even-fancier-families">Even
fancier families</a>).</p>
<p>To simplify the <code>Stan</code> code that decodes this data
structure, we also pass three additional <code>vint</code> terms:</p>
<ul>
<li>the first giving <span class="math inline">\(N\)</span> as its first
element, with all subsequent elements irrelevant,</li>
<li>the second giving the total number of repeat visits at each
closure-unit as its first <span class="math inline">\(N\)</span>
elements, with all subsequent elements irrelevant,</li>
<li>and the third containing a pre-computed binary indicator for whether
or not a closure-unit has at least one detection as its first <span class="math inline">\(N\)</span> elements, with all subsequent elements
irrelevant.</li>
</ul>
<p>Thus, the likelihood function has a number of <code>vint</code> terms
equal to three plus the maximum number of repeat visits to any site. The
<code>Stan</code> code to decode this format depends on the number of
repeat visits and is generated on-the-fly at runtime. Here’s how it
looks for a dataset with a maximum of four repeat visits:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="fu">flocker</span><span class="fu">:::</span><span class="fu"><a href="../reference/make_occupancy_single_lpmf.html">make_occupancy_single_lpmf</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   real occupancy_single_lpmf(</span></span>
<span><span class="co">##     array[] int y, // detection data</span></span>
<span><span class="co">##     vector mu, // lin pred for detection</span></span>
<span><span class="co">##     vector occ, // lin pred for occupancy. Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint1, // # units (n_unit). Elements after 1 irrelevant.</span></span>
<span><span class="co">##     array[] int vint2, // # sampling events per unit (n_rep). Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint3, // Indicator for &gt; 0 detections (Q). Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##   </span></span>
<span><span class="co">##   // indices for jth repeated sampling event to each unit (elements after vint1[1] irrelevant):</span></span>
<span><span class="co">##     array[] int vint4,</span></span>
<span><span class="co">##     array[] int vint5,</span></span>
<span><span class="co">##     array[] int vint6,</span></span>
<span><span class="co">##     array[] int vint7</span></span>
<span><span class="co">## ) {</span></span>
<span><span class="co">##   // Create array of the rep indices that correspond to each unit.</span></span>
<span><span class="co">##     array[vint1[1], 4] int index_array;</span></span>
<span><span class="co">##       index_array[,1] = vint4[1:vint1[1]];</span></span>
<span><span class="co">##       index_array[,2] = vint5[1:vint1[1]];</span></span>
<span><span class="co">##       index_array[,3] = vint6[1:vint1[1]];</span></span>
<span><span class="co">##       index_array[,4] = vint7[1:vint1[1]];</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   // Initialize and compute log-likelihood</span></span>
<span><span class="co">##     real lp = 0;</span></span>
<span><span class="co">##     for (i in 1:vint1[1]) {</span></span>
<span><span class="co">##       array[vint2[i]] int indices = index_array[i, 1:vint2[i]];</span></span>
<span><span class="co">##       if (vint3[i] == 1) {</span></span>
<span><span class="co">##         lp += bernoulli_logit_lpmf(1 | occ[i]);</span></span>
<span><span class="co">##         lp += bernoulli_logit_lpmf(y[indices] | mu[indices]);</span></span>
<span><span class="co">##       }</span></span>
<span><span class="co">##       if (vint3[i] == 0) {</span></span>
<span><span class="co">##         lp += log_sum_exp(bernoulli_logit_lpmf(1 | occ[i]) + </span></span>
<span><span class="co">##                               sum(log1m_inv_logit(mu[indices])), bernoulli_logit_lpmf(0 | occ[i]));</span></span>
<span><span class="co">##       }</span></span>
<span><span class="co">##     }</span></span>
<span><span class="co">##     return(lp);</span></span>
<span><span class="co">##   }</span></span></code></pre>
<p>In addition to the functions to generate this custom
<code>Stan</code> code, the main workhorses in <code>flocker</code> are
functions to pack and unpack data and linear predictors from the shape
of the observational data to the <code>flocker_data</code> format (and
back). For further details, check out
<code>flocker:::make_flocker_data_static</code> (for packing) and
<code>flocker:::get_positions</code> (for unpacking).</p>
<div class="section level3">
<h3 id="a-note-on-performance">A note on performance<a class="anchor" aria-label="anchor" href="#a-note-on-performance"></a>
</h3>
<p>As noted, the <code>flocker</code> approach to fitting in
<code>brms</code> contains one substantial redundancy, which is that the
linear predictor for occupancy gets computed redundantly several-fold
too many times, since it need be computed only once per closure-unit,
whereas <code>flocker</code> computes it once per visit. In addition, it
is not possible to use <code>Stan</code>’s <code>reduce_sum</code>
functionality for within-chain parallelization of the computation of the
linear predictors, since chunking up the data destroys the validity of
the indexing (and requires a level of control that
<code>reduce_sum</code> does not provide to ensure that no closure-units
end up split across multiple chunks). Despite these disadvantages, we
find that occupancy modeling with <code>flocker</code> is remarkably
performant, in many cases outperforming our previous hand-coded
<code>Stan</code> implementations of models for large datasets and
comparing favorably to other contemporary packages for occupancy
modeling.</p>
</div>
</div>
<div class="section level2">
<h2 id="even-fancier-families">Even fancier families<a class="anchor" aria-label="anchor" href="#even-fancier-families"></a>
</h2>
<p>Flocker provides a set of families that are more involved still. The
first are the multi-season families, which group closure-units into
series within which the occupancy state changes via modeled colonization
and extinction dynamics. The second are data-augmented multi-species
models, in which closure-units are grouped within species whose presence
in the community (and thus availablility for detection) is modeled
explicitly.</p>
<div class="section level3">
<h3 id="the-multi-species-format">The multi-species format<a class="anchor" aria-label="anchor" href="#the-multi-species-format"></a>
</h3>
<p>For we fit multi-species models via a hidden Markov model (HMM)
approach to the likelihood. This vignette does not cover the
implementation of that likelihood in detail–just the necessary data that
we need to send to the un-looped likelihood function. Suppose the data
contain <span class="math inline">\(S\)</span> distinct series
(i.e. distinct hidden Markov sequences), <span class="math inline">\(U\)</span> closure-units (i.e. the sum over series
of the number of timesteps per series). The data are ordered so that the
first <span class="math inline">\(S\)</span> rows correspond to the
first repeat visit to the first timestep of all series (or to a ghost
row if a given series has no visits in the first timestep), and the
first <span class="math inline">\(U\)</span> rows correspond to the
first repeat visit to each closure-unit (i.e. timestep, or a ghost row
if a given timestep contains no visits).</p>
<p>We pass:</p>
<ul>
<li>A <code>vint</code> term for the number of series <span class="math inline">\(S\)</span>. Elements after the first are
irrelevant.</li>
<li>A <code>vint</code> term for the total number of closure-units <span class="math inline">\(U\)</span>, including never-visited closure-units.
Elements after the first are irrelevant.</li>
<li>A <code>vint</code> term for the number of closure-units (timesteps)
in each series. Elements after <span class="math inline">\(S\)</span>
are irrelevant.</li>
<li>A <code>vint</code> term for the number of sampling events in each
closure-unit. Elements after <span class="math inline">\(U\)</span> are
irrelevant.</li>
<li>A <code>vint</code> term giving the binary indicator <span class="math inline">\(Q\)</span> for whether there is at least one
detection. Elements after <span class="math inline">\(U\)</span> are
irrelevant.</li>
<li>Multiple <code>vint</code> terms, one for each timestep up to the
maximum number of timesteps in any series, giving the row index of the
first visit in that timestep within each series. Elements after <span class="math inline">\(S\)</span> are irrelevant.</li>
<li>Multiple <code>vint</code> terms, one for each sampling event up to
the maximum number of sampling events in any unit, giving the row index
corresponding to that visit. Elements after <span class="math inline">\(U\)</span> are irrelevant.</li>
</ul>
<p>Thus, we pass a number of <code>vint</code> terms equal to four plus
the maximum number of timesteps in any series plus the maximum number of
visits in any timestep. Here’s <code>Stan</code> code to decode this
format and compute the likelihood for 5 timesteps with a maximum of 4
repeat visits, in this case for the colonization-extinction flavor of
multispecies model. Note that this likeliihood includes custom functions
that <code>flocker</code> defines elsewhere and passes to the custom
family via <code>stanvars</code>:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="fu">flocker</span><span class="fu">:::</span><span class="fu"><a href="../reference/make_occupancy_multi_colex_lpmf.html">make_occupancy_multi_colex_lpmf</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   real occupancy_multi_colex_lpmf(</span></span>
<span><span class="co">##     array[] int y, // detection data</span></span>
<span><span class="co">##     vector mu, // linear predictor for detection</span></span>
<span><span class="co">##     vector occ, // linear predictor for initial occupancy. Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     vector colo, // linear predictor for colonization. Elements after vint2[1] irrelevant.</span></span>
<span><span class="co">##     vector ex, // linear predictor for extinction. Elements after vint2[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint1, // # of series (# of HMMs). Elements after 1 irrelevant.</span></span>
<span><span class="co">##     array[] int vint2, // # units (series-years). Elements after 1 irrelevant.</span></span>
<span><span class="co">##     array[] int vint3, // # years per series. Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint4, // # sampling events per unit (n_rep). Elements after vint2[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint5, // Indicator for &gt; 0 detections (Q). Elements after vint2[1] irrelevant.</span></span>
<span><span class="co">##   </span></span>
<span><span class="co">##   // indices for jth unit (first rep) for each series. Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint6,</span></span>
<span><span class="co">##     array[] int vint7,</span></span>
<span><span class="co">##     array[] int vint8,</span></span>
<span><span class="co">##     array[] int vint9,</span></span>
<span><span class="co">##     array[] int vint10,</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## // indices for jth repeated sampling event to each unit (elements after vint2[1] irrelevant):</span></span>
<span><span class="co">##     array[] int vint11,</span></span>
<span><span class="co">##     array[] int vint12,</span></span>
<span><span class="co">##     array[] int vint13,</span></span>
<span><span class="co">##     array[] int vint14</span></span>
<span><span class="co">## ) {</span></span>
<span><span class="co">##   // Create array of the unit indices that correspond to each series.</span></span>
<span><span class="co">##     array[vint1[1], 5] int unit_index_array;</span></span>
<span><span class="co">##       unit_index_array[,1] = vint6[1:vint1[1]];</span></span>
<span><span class="co">##       unit_index_array[,2] = vint7[1:vint1[1]];</span></span>
<span><span class="co">##       unit_index_array[,3] = vint8[1:vint1[1]];</span></span>
<span><span class="co">##       unit_index_array[,4] = vint9[1:vint1[1]];</span></span>
<span><span class="co">##       unit_index_array[,5] = vint10[1:vint1[1]];</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   // Create array of the rep indices that correspond to each unit.</span></span>
<span><span class="co">##     array[vint2[1], 4] int visit_index_array;</span></span>
<span><span class="co">##       visit_index_array[,1] = vint11[1:vint2[1]];</span></span>
<span><span class="co">##       visit_index_array[,2] = vint12[1:vint2[1]];</span></span>
<span><span class="co">##       visit_index_array[,3] = vint13[1:vint2[1]];</span></span>
<span><span class="co">##       visit_index_array[,4] = vint14[1:vint2[1]];</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   // Initialize and compute log-likelihood</span></span>
<span><span class="co">##     real lp = 0;</span></span>
<span><span class="co">##     for (i in 1:vint1[1]) {</span></span>
<span><span class="co">##       int n_year = vint3[i];</span></span>
<span><span class="co">##       array[n_year] int Q = vint5[unit_index_array[i,1:n_year]];</span></span>
<span><span class="co">##       array[n_year] int n_obs = vint4[unit_index_array[i,1:n_year]];</span></span>
<span><span class="co">##       int max_obs = max(n_obs);</span></span>
<span><span class="co">##       array[n_year, max_obs] int y_i;</span></span>
<span><span class="co">##       real occ_i = occ[unit_index_array[i,1]];</span></span>
<span><span class="co">##       vector[n_year] colo_i = to_vector(colo[unit_index_array[i,1:n_year]]);</span></span>
<span><span class="co">##       vector[n_year] ex_i = to_vector(ex[unit_index_array[i,1:n_year]]);</span></span>
<span><span class="co">##       array[n_year] row_vector[max_obs] det_i;</span></span>
<span><span class="co">##       </span></span>
<span><span class="co">##       for (j in 1:n_year) {</span></span>
<span><span class="co">##         if (n_obs[j] &gt; 0) {</span></span>
<span><span class="co">##           y_i[j, 1:n_obs[j]] = y[visit_index_array[unit_index_array[i, j], 1:n_obs[j]]];</span></span>
<span><span class="co">##           det_i[j, 1:n_obs[j]] = to_row_vector(mu[visit_index_array[unit_index_array[i, j], 1:n_obs[j]]]);</span></span>
<span><span class="co">##         }</span></span>
<span><span class="co">##       }</span></span>
<span><span class="co">##       lp += forward_colex(n_year, Q, n_obs, y_i, occ_i, colo_i, ex_i, det_i);</span></span>
<span><span class="co">##     }</span></span>
<span><span class="co">##     return(lp);</span></span>
<span><span class="co">##   }</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="the-data-augmented-format">The data augmented format<a class="anchor" aria-label="anchor" href="#the-data-augmented-format"></a>
</h3>
<p>For the data augmented model, suppose that the dataset contains <span class="math inline">\(I\)</span> sites, up to <span class="math inline">\(J\)</span> visits per site, and <span class="math inline">\(K\)</span> species (including the data-augmented
pseudospecies). The data are ordered so that the first <span class="math inline">\(I \times K\)</span> rows each represent the first
visit to each closure-unit (species <span class="math inline">\(\times\)</span> site). Then we pass auxiliary
terms including:</p>
<ul>
<li>A <code>vint</code> term giving the total number of closure-units
<span class="math inline">\(I \times K\)</span>. Elements after the
first are irrelevant.</li>
<li>A <code>vint</code> term giving the number of sampling events per
closure-unit. Elements after <span class="math inline">\(I \times
K\)</span> are irrelevant.</li>
<li>A <code>vint</code> term giving the binary indicator <span class="math inline">\(Q\)</span> for whether there is at least one
detection. Elements after <span class="math inline">\(I \times
K\)</span> are irrelevant.</li>
<li>A <code>vint</code> term giving the number of species <span class="math inline">\(K\)</span>. Elements after the first are
irrelevant.</li>
<li>A <code>vint</code> term giving a binary indicator for whether there
is at least one observation of a species. Elements after <span class="math inline">\(K\)</span> are irrelevant.</li>
<li>A <code>vint</code> term giving the species to which a closure-unit
belongs. Elements after <span class="math inline">\(I \times K\)</span>
are irrelevant.</li>
<li>Multiple <code>vint</code> terms, one for each sampling event up to
the maximum number of sampling events at any site, giving the row index
corresponding to that visit. Elements after <span class="math inline">\(I \times K\)</span> are irrelevant.</li>
</ul>
<p>Thus, we pass a number of <code>vint</code> terms equal to six plus
the maximum number of visits at any site. Here’s <code>Stan</code> code
to decode this format and compute the likelihood a dataset with a
maximum of 4 repeat visits.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="fu">flocker</span><span class="fu">:::</span><span class="fu"><a href="../reference/make_occupancy_augmented_lpmf.html">make_occupancy_augmented_lpmf</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   real occupancy_augmented_lpmf(</span></span>
<span><span class="co">##     array[] int y, // detection data</span></span>
<span><span class="co">##     vector mu, // lin pred for detection</span></span>
<span><span class="co">##     vector occ, // lin pred for occupancy. Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     vector Omega, // lin pred for availability.  Elements after 1 irrelevant.</span></span>
<span><span class="co">##     array[] int vint1, // # units (n_unit). Elements after 1 irrelevant.</span></span>
<span><span class="co">##     array[] int vint2, // # sampling events per unit (n_rep). Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     array[] int vint3, // Indicator for &gt; 0 detections (Q). Elements after vint1[1] irrelevant.</span></span>
<span><span class="co">##     </span></span>
<span><span class="co">##     array[] int vint4, // # species (observed + augmented). Elements after 1 irrelevant.</span></span>
<span><span class="co">##     array[] int vint5, // Indicator for species was observed.  Elements after vint4[1] irrelevant</span></span>
<span><span class="co">##     </span></span>
<span><span class="co">##     array[] int vint6, // species</span></span>
<span><span class="co">##   </span></span>
<span><span class="co">##   // indices for jth repeated sampling event to each unit (elements after vint1[1] irrelevant):</span></span>
<span><span class="co">##     array[] int vint7,</span></span>
<span><span class="co">##     array[] int vint8,</span></span>
<span><span class="co">##     array[] int vint9,</span></span>
<span><span class="co">##     array[] int vint10</span></span>
<span><span class="co">## ) {</span></span>
<span><span class="co">##   // Create array of the rep indices that correspond to each unit.</span></span>
<span><span class="co">##     array[vint1[1], 4] int index_array;</span></span>
<span><span class="co">##       index_array[,1] = vint7[1:vint1[1]];</span></span>
<span><span class="co">##       index_array[,2] = vint8[1:vint1[1]];</span></span>
<span><span class="co">##       index_array[,3] = vint9[1:vint1[1]];</span></span>
<span><span class="co">##       index_array[,4] = vint10[1:vint1[1]];</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   // Initialize and compute log-likelihood</span></span>
<span><span class="co">##     real lp = 0;</span></span>
<span><span class="co">##     </span></span>
<span><span class="co">##     for (sp in 1:vint4[1]) {</span></span>
<span><span class="co">##       real lp_s = 0;</span></span>
<span><span class="co">##       if (vint5[sp] == 1) {</span></span>
<span><span class="co">##         for (i in 1:vint1[1]) {</span></span>
<span><span class="co">##           if (vint6[i] == sp) {</span></span>
<span><span class="co">##             array[vint2[i]] int indices = index_array[i, 1:vint2[i]];</span></span>
<span><span class="co">##             if (vint3[i] == 1) {</span></span>
<span><span class="co">##               lp_s += bernoulli_logit_lpmf(1 | occ[i]);</span></span>
<span><span class="co">##               lp_s += bernoulli_logit_lpmf(y[indices] | mu[indices]);</span></span>
<span><span class="co">##             }</span></span>
<span><span class="co">##             if (vint3[i] == 0) {</span></span>
<span><span class="co">##               lp_s += log_sum_exp(bernoulli_logit_lpmf(1 | occ[i]) + </span></span>
<span><span class="co">##                                     sum(log1m_inv_logit(mu[indices])), bernoulli_logit_lpmf(0 | occ[i]));</span></span>
<span><span class="co">##             }</span></span>
<span><span class="co">##           }</span></span>
<span><span class="co">##         }</span></span>
<span><span class="co">##         lp += log_inv_logit(Omega[1]) + lp_s;</span></span>
<span><span class="co">##       } else {</span></span>
<span><span class="co">##         for (i in 1:vint1[1]) {</span></span>
<span><span class="co">##           if (vint6[i] == sp) {</span></span>
<span><span class="co">##             array[vint2[i]] int indices = index_array[i, 1:vint2[i]];</span></span>
<span><span class="co">##             lp_s += log_sum_exp(bernoulli_logit_lpmf(1 | occ[i]) + </span></span>
<span><span class="co">##                                   sum(log1m_inv_logit(mu[indices])), bernoulli_logit_lpmf(0 | occ[i]));</span></span>
<span><span class="co">##           }</span></span>
<span><span class="co">##         }</span></span>
<span><span class="co">##         lp += log_sum_exp(log1m_inv_logit(Omega[1]), log_inv_logit(Omega[1]) + lp_s);  </span></span>
<span><span class="co">##       }</span></span>
<span><span class="co">##     }</span></span>
<span><span class="co">##     return(lp);</span></span>
<span><span class="co">##   }</span></span></code></pre>
<center>
<p><img src="../reference/figures/logo2.png" style="border:none;;width:30.0%"></p>
</center>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Jacob B. Socolar, Simon C. Mills.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
